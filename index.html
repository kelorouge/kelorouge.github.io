<!DOCTYPE html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <title>Kelo's Page</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Comic+Neue&display=swap" rel="stylesheet">
  <style>
    :root {
      --color-primary: #231942;
      --color-secondary: #9F86C0;
      --color-accent: #E0B1CB;
      --color-background: #BE95C4;
      --color-text: #E0B1CB;
      --color-border: #5E548E;
    }

    @keyframes twinkle {
      0% { transform: scale(0.8); opacity: 0.3; }
      100% { transform: scale(1); opacity: 1; }
    }
    @keyframes scroll-left {
      0% { transform: translateX(0); }
      100% { transform: translateX(-100%); }
    }

    body {
      background-color: var(--color-primary);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      font-weight: bold;
      margin: 0;
      padding: 20px;
      color: var(--color-text);
      position: relative;
      overflow-x: hidden;
    }
    .scroll-container {   
      width: 80%;
      margin: -10px auto 10px;
      overflow: hidden;
      white-space: nowrap;
    }
    .scroll-text {
      display: inline-block;
      color: #D0B0DC;
      animation: scroll-left 20s linear infinite;
      padding-left: 100%;
    }
    .profile-area {
      position: relative;
      background: linear-gradient(45deg, var(--color-secondary), var(--color-border));
      display: flex;
      align-items: center;
      padding: 20px;
      margin: 0 0 10px 7.5%;
      border: 3px solid var(--color-border);
      width: 250px;
      min-width: 250px;
      border-radius: 15px;
      box-sizing: border-box;
      justify-content: flex-start;
    }
    .profile-info {
      display: flex;
      align-items: center;
      width: 100%;
    }
    .profile-pic {
      width: 100px;
      height: 100px;
      background-color: var(--color-background);
      border: 4px solid var(--color-accent);
      margin-right: 15px;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
      cursor: pointer;
      transition: transform 0.2s ease-in-out;
      border-radius: 15px;
      flex-shrink: 0;
    }
    .profile-pic:hover {
      transform: scale(1.05);
    }
    .profile-pic img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 12px;
    }
    .profile-text {
      display: flex;
      flex-direction: column;
    }
    .profile-text h2,
    .profile-title {
      margin: 0;
    }
    .container {
      display: flex;
      width: 85%;
      min-height: 600px;
      margin: 20px auto;
      border: none;
      box-sizing: border-box;
    }
    .blog-sidebar {
      width: 15%;
      background-color: var(--color-background);
      padding: 10px;
      position: relative;
      border-radius: 15px;
      margin-right: 10px;
      padding-bottom: 70px;
      box-sizing: border-box;
    }
    .blog-post {
      cursor: pointer;
      padding: 10px;
      margin-bottom: 5px;
      background-color: var(--color-secondary);
      color: var(--color-text);
      transition: background-color 0.3s ease;
      border: none;
      width: 100%;
      text-align: left;
      font-family: inherit;
      font-size: inherit;
      border-radius: 8px;
      box-sizing: border-box;
    }
    .blog-post:hover,
    .blog-post.active {
      background-color: var(--color-border);
      font-weight: bold;
    }
    .about-section {
      width: 85%;
      padding: 20px;
      background-color: #60558C;
      color: var(--color-text);
      font-size: 1.2rem;
      border-radius: 15px;
      border: 3px solid var(--color-border);
      margin: 20px auto;
      overflow-y: auto;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      align-items: center;
	  
	.about-me-center {
  text-align: center;
}


    }
    .drawing-container {
      position: relative;
      background-color: var(--color-secondary);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
	
	
    .tools-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
    }
    #drawingCanvas {
      background-color: white;
      border: 3px solid var(--color-border);
      border-radius: 8px;
      cursor: crosshair;
      touch-action: none;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    .canvas-controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-top: 15px;
      padding: 0 20px;
    }
    .canvas-tool-group {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }
    .canvas-send-group {
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .tool-controls {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-left: 15px;
    }
    .brush-controls {
      background-color: var(--color-primary);
      padding: 8px 15px;
      border: 2px solid var(--color-border);
      border-radius: 8px;
    }
    #colorPicker {
      -webkit-appearance: none;
      width: 40px;
      height: 40px;
      padding: 0;
      border: 2px solid var(--color-border);
      border-radius: 6px;
      cursor: pointer;
      background-color: var(--color-primary);
      box-shadow: none;
    }
    #colorPicker::-webkit-color-swatch-wrapper {
      padding: 0;
      border-radius: 6px;
    }
    #colorPicker::-webkit-color-swatch {
      border: none;
      border-radius: 6px;
    }
    #brushSize {
      -webkit-appearance: none;
      width: 100px;
      height: 4px;
      background: var(--color-secondary);
      border-radius: 2px;
      border: none;
      outline: none;
    }
    #brushSize::-webkit-slider-runnable-track {
      width: 100%;
      height: 4px;
      background-color: var(--color-secondary);
      border-radius: 2px;
      border: 1px solid var(--color-border);
    }
    #brushSize::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      background: var(--color-accent);
      border: 2px solid var(--color-border);
      border-radius: 50%;
      cursor: pointer;
      margin-top: -6px;
    }
    #brushSizeDisplay {
      background-color: var(--color-secondary);
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 14px;
    }
    .doodle-signature {
      display: none;
      width: 160px;
      padding: 8px;
      border: 2px solid var(--color-border);
      border-radius: 8px;
      background-color: var(--color-primary);
      color: var(--color-text);
      font-size: 14px;
      box-sizing: border-box;
      margin-right: 10px;
    }
    .tool-btn, .icon-btn {
      background-color: var(--color-primary);
      color: var(--color-text);
      border: 2px solid var(--color-border);
      border-radius: 6px;
      padding: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .tool-btn:hover, .icon-btn:hover {
      background-color: var(--color-border);
      transform: translateY(-2px);
    }
    .tool-btn.active {
      background-color: var(--color-border);
      transform: translateY(1px);
    }
    .icon-btn.disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .message-container {
      background-color: #9d85be;
      color: var(--color-text);
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
      margin-top: 30px;
      display: flex;
      justify-content: center;
      width: 65%;
    }
    .about-box {
      background-color: var(--color-text);
      color: #60558C;
      max-width: 300px;
      margin: 20px auto 0;
      padding: 15px;
      border: 2px solid var(--color-border);
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      text-align: center;
    }
    .about-box h3 {
      margin-top: 0;
      color: inherit;
    }
    .about-box p {
      margin-bottom: 0;
      font-size: 1rem;
    }
    .message-box {
      width: 100%;
      max-width: 600px;
      display: flex;
      flex-direction: column;
      gap: 20px;
      align-items: center;
    }
    .message-input-container {
      position: relative;
      width: 100%;
    }
    .message-input {
      width: 100%;
      padding: 12px;
      border: 2px solid var(--color-border);
      border-radius: 8px;
      background-color: var(--color-primary);
      color: var(--color-text);
      font-size: 14px;
      resize: none;
      box-sizing: border-box;
    }
    .message-input:focus {
      outline: none;
      border-color: var(--color-accent);
    }
    .message-counter {
      position: absolute;
      bottom: 8px;
      right: 10px;
      font-size: 12px;
      color: var(--color-accent);
    }
    .message-controls {
      width: 100%;
      display: flex;
      justify-content: flex-end;
    }
    .control-btn {
      background-color: var(--color-secondary);
      color: var(--color-text);
      font-size: 16px;
      padding: 10px 20px;
      border: 2px solid var(--color-border);
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.3s ease, transform 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .control-btn i {
      font-size: 18px;
    }
    .control-btn:hover {
      background-color: #7D73B5;
      color: #FFF;
      transform: translateY(-2px);
    }
    .control-btn:active {
      background-color: var(--color-primary);
    }
    #sendBtn {
      margin-left: auto;
    }
    .message-status {
      text-align: center;
      margin-top: 10px;
      font-size: 14px;
      color: var(--color-accent);
    }
    .social-icons {
      position: static;
      margin-top: 10px;
      margin-bottom: 10px;
      width: 100%;
      display: flex;
      justify-content: center;
    }
    .social-icon {
      width: 35px;
      height: 35px;
      background-color: var(--color-border);
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 0 7px;
      cursor: pointer;
      transition: transform 0.3s ease;
    }
    .social-icon:hover {
      transform: scale(1.1);
    }
    .social-icon a {
      color: var(--color-text);
      font-size: 18px;
      text-decoration: none;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    @media (max-width: 768px) {
      body {
        padding: 10px;
      }
      .container {
        flex-direction: column;
        width: 100%;
        margin: 10px auto;
        min-height: auto;
      }
      .blog-sidebar {
        width: auto;
        margin: 0 0 20px 0;
        padding: 20px;
      }
      .about-section {
        width: auto;
        margin: 0;
        padding: 25px;
      }
      .profile-area {
        width: 100%;
        margin: 0 auto 20px;
        padding: 15px;
      }
      .profile-pic {
        width: 80px;
        height: 80px;
      }
      .scroll-container {
        width: 95%;
      }
      #drawingCanvas {
        max-width: 100%;
        height: auto;
      }
      .tools-row {
        width: 100%;
      }
    }
    @media (max-width: 480px) {
      .profile-pic {
        width: 70px;
        height: 70px;
      }
      .profile-text h2 {
        font-size: 1.2em;
      }
      .profile-title {
        font-size: 1em;
      }
      .social-icons {
        flex-wrap: wrap;
        gap: 15px;
        justify-content: space-around;
        padding: 15px 0;
      }
	  
      .social-icon {
        margin: 0;
      }
    }

    /* Fridge Gallery Styles */
    .fridge-gallery {
      display: flex;
      flex-wrap: wrap;
      gap: 25px; /* Spacing between doodles */
      padding: 20px;
      justify-content: center; /* Center doodles horizontally */
      background-color: rgba(255, 255, 255, 0.1); /* Slightly lighter background */
      border-radius: 10px;
      margin-top: 20px;
    }

    .fridge-doodle {
      position: relative; /* Needed for the pseudo-element magnet */
      background-color: #ffffff; /* White paper background */
      padding: 8px; /* Padding around the image */
      border: 1px solid #ccc; /* Light border for the paper */
      box-shadow: 3px 3px 6px rgba(0, 0, 0, 0.2); /* Drop shadow */
      max-width: 200px; /* Max width for each doodle container */
      transition: transform 0.2s ease-in-out;
      /* Optional: slight random rotation for realism */
      /* transform: rotate(calc(random() * 6deg - 3deg)); /* Needs browser support or JS */ 
    }

    .fridge-doodle:hover {
        transform: scale(1.05); /* Slight zoom on hover */
    }

    .fridge-doodle img {
      display: block; /* Remove extra space below image */
      max-width: 100%; /* Ensure image fits within the padding */
      height: auto; /* Maintain aspect ratio */
    }

    /* Pseudo-element for the 'magnet' */
    .fridge-doodle::before {
      content: '';
      position: absolute;
      top: -10px; /* Position above the doodle */
      left: calc(50% - 12px); /* Center the magnet */
      width: 24px;
      height: 24px;
      background-color: #E74C3C; /* Red magnet color, adjust as needed */
      border-radius: 50%; /* Make it round */
      box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.4); /* Magnet shadow */
      border: 2px solid #C0392B; /* Darker border for magnet */
    }

  </style>
</head>
<body>
  <div class="scroll-container">
    <div class="scroll-text">✨ Shooting Star ✨</div>
  </div>

  <div class="profile-area">
    <div class="profile-info">
      <div class="profile-pic">
        <a href="https://bsky.app/profile/rogue.red" target="_blank" rel="noopener noreferrer">
          <img src="https://cdn.bsky.app/img/avatar/plain/did:plc:fmzp7iyocwxuadfrpmllnlfm/bafkreigzp442ifkmddxo73ejx4ilezjqhbi7kwxee6ylifc2abg4t2rfc4@jpeg"
               alt="Profile Picture" loading="lazy">
        </a>
      </div>
      <div class="profile-text">
        <h2>Kelo✨</h2>
        <h3 class="profile-title">Pixel Rogue</h3>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="blog-sidebar">
      <div class="social-icons">
        <div class="social-icon">
          <a href="https://open.spotify.com/user/12156433469?si=ba65b834f69b4e2c" target="_blank" rel="noopener noreferrer">
            <i class="fab fa-spotify"></i>
          </a>
        </div>
        <div class="social-icon">
          <a href="https://bsky.app/profile/rogue.red" target="_blank" rel="noopener noreferrer">
            <i class="fab fa-bluesky"></i>
          </a>
        </div>
        <div class="social-icon">
          <a href="https://steamcommunity.com/profiles/76561198856300045/" target="_blank" rel="noopener noreferrer">
            <i class="fab fa-steam"></i>
          </a>
        </div>
      </div>
      <div class="tab-list" id="tabList"></div>
    </div>

    <div class="about-section" id="tabContent"></div>
  </div>

  <script>
    const tabs = [
      {
        id: 'tab-4',
        title: 'Doodles & Letters',
        content: `
          <h1 style="text-align: center">Leave a drawing or message!</h1>
          <div class="drawing-container">
            <div class="tools-row">
              <button class="tool-btn" id="pixelBtn" title="Toggle Pixel Art Mode">
                <i class="fas fa-th"></i>
              </button>
              <button class="tool-btn active" id="brushBtn" title="Brush Tool">
                <i class="fas fa-paint-brush"></i>
              </button>
              <button class="tool-btn" id="eraserBtn" title="Eraser">
                <i class="fas fa-eraser"></i>
              </button>
              <button class="tool-btn" id="fillBtn" title="Fill Tool">
                <i class="fas fa-fill-drip"></i>
              </button>
              <button class="icon-btn" id="undoBtn" title="Undo">
                <i class="fas fa-undo"></i>
              </button>
              <button class="icon-btn" id="redoBtn" title="Redo">
                <i class="fas fa-redo"></i>
              </button>
              <button class="icon-btn" id="clearBtn" title="Clear Canvas">
                <i class="fas fa-trash-alt"></i>
              </button>
            </div>
            <div style="position: relative; width: 500px; height: 400px;">
              <canvas id="drawingCanvas" width="500" height="400"></canvas>
              <canvas id="gridCanvas" width="500" height="400" style="position: absolute; top: 0; left: 0; pointer-events: none; display: none;"></canvas>
            </div>
          </div>
          <div class="canvas-controls">
            <div class="canvas-tool-group">
              <input type="color" id="colorPicker" value="#000000" title="Choose Color">
              <div class="brush-controls">
                <input type="range" id="brushSize" min="1" max="50" value="5" title="Brush Size">
                <span id="brushSizeDisplay">5px</span>
              </div>
            </div>
            <div class="canvas-send-group">
              <input 
                type="text" 
                class="doodle-signature" 
                id="doodleSignature" 
                placeholder="Sign your doodle (optional)"
              >
              <button class="control-btn" id="sendBtn">Send Doodle!</button>
            </div>
          </div>
          <div class="message-container">
            <div class="message-box">
              <div class="message-input-container">
                <textarea 
                  id="messageText"
                  placeholder="Type your message here... (Press Ctrl+Enter to send)"
                  rows="4"
                  class="message-input"
                  maxlength="2000"
                ></textarea>
                <div class="message-counter">0/2000</div>
              </div>
              <div class="message-controls">
                <button class="control-btn" id="sendMessageBtn">
                  <i class="fas fa-paper-plane"></i>
                  Send Message
                </button>
              </div>
            </div>
          </div>
        `
      },
      {
        id: 'tab-3',
        title: 'The Fridge',
        content: `
          <h1 style="text-align: center">The Fridge</h1>
          <p style="text-align: center">A gallery of doodles left by visitors!</p>
          <div class="fridge-gallery">
            
             <!-- Doodles copy and paste  -->
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/RkSQMg2.png" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/jSeLARQ.png" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/goQyd2Z.png" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/shZVgKD.png" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/Tnx9YuS.png" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/8Mn0SaJ.png" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/2wgJ96y.png" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/AwtHUzz.png" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/8UxnTqT.png" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/cqMaFR1.png" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/siunHeo.png" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/e5t1U2s.png" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/onrgiAB.png" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/FccSsL1.png" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/siq9fpF.jpg" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/v822sVF.jpg" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/4rbjtWQ.jpg" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/KZ5D2bd.jpg" alt="Visitor Doodle">
              </div>
              <div class="fridge-doodle">
               <img src="https://i.imgur.com/mfucOoD.jpg" alt="Visitor Doodle">
              </div>
              
            
          </div>
        `
      },
      {
        id: 'tab-2',
        title: 'My Art',
        content: `
          <h1>My Art</h1>
          <p>Still a work in progress, but I'll share my art here soon!</p>
        `
      },
      {
        id: 'tab-1',
        title: 'About Me',
        content: `
		<div class="about-me-center">
          <h1>About Me</h1>
          <p>Kelo | 25 | He/They | Demisexual<br>
		  <br>
          <h2>✨ Interests ✨</h2>
		  Fire Emblem<br>
          Kirby!<br>
          Pokemon<br>
		  Soulsborne<br>
          Kingdom Hearts<br>
          The Legend of Zelda<br>
		  Final Fantasy / XIV<br>
		  Mega Man Battle Network<br>
		  <br>
		  <h4>✨Other✨</h4>
		  Pixel art, HTML, fantasy books, and romance manga! <br><br><br><br>
		  
		  
		  
		  </p>
          <p>All of my spaces are kept safe and positive, so please do not bring any drama or politics to me!<br>
             ✨I'm here to make you happy!✨</p>
          <div class="about-box">
            <h3>DNI</h3>
            <p>Minors, accounts focused on drama/politics, or primarily NSFW content.</p>
          </div>
		</div>
        `
      }
    ];

    let currentCanvas = null;
    let currentContext = null;
	

    function initDrawingCanvas() {
      const canvas = document.getElementById('drawingCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = false; 
	  const gridCanvas = document.getElementById('gridCanvas'); 
      const gtx = gridCanvas ? gridCanvas.getContext('2d') : null; 


	  let pixelMode = false; // Re-enable pixel mode flag

      const sendBtn = document.getElementById('sendBtn');
      const doodleSignature = document.getElementById('doodleSignature');
      let signaturePrompted = false;

      
      sendBtn.addEventListener('click', async () => {
        if (!signaturePrompted) {
          signaturePrompted = true;
          doodleSignature.style.display = 'inline-block';
          sendBtn.textContent = 'Send Now';
          return;
        }
        sendBtn.disabled = true;
        sendBtn.textContent = 'Sending...';
        const webhookUrl = 'https://discord.com/api/webhooks/1324823445082607706/WFRr5qQlIf7584EYlb62BgPbzoq19nGKXfNrJncnHtMW1kXgsp6Hq_RUqqWu5AOyx3FZ';
        try {
          const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
          if (!blob) throw new Error('Blob creation failed');
          const formData = new FormData();
          formData.append('file', blob, 'doodle.png');
          const signatureValue = doodleSignature.value.trim();
          if (signatureValue) {
            formData.append('content', `**Doodle by:** ${signatureValue}`);
          }
          const response = await fetch(webhookUrl, { method: 'POST', body: formData });
          if (!response.ok) throw new Error('Failed to send');
          sendBtn.textContent = 'Doodle Sent!';
        } catch (error) {
          console.error('Error sending doodle:', error);
          sendBtn.textContent = 'Error Sending';
        } finally {
          setTimeout(() => {
            sendBtn.disabled = false;
            sendBtn.textContent = 'Send Doodle!';
            doodleSignature.style.display = 'none';
            doodleSignature.value = '';
            signaturePrompted = false;
          }, 5000);
        }
      });
      


      const colorPicker = document.getElementById('colorPicker');
      const brushSize = document.getElementById('brushSize');

      
      const state = {
        isDrawing: false,
        tool: 'brush',
        lastX: 0,
        lastY: 0,
        lastSnappedX: -1, 
        lastSnappedY: -1, 
        undoStack: [],
        redoStack: [],
        maxStates: 50
      };

      const pixelSize = 20; 

      const canvasBorderSize = 3; // Define the border size from CSS

      

      function updateContextSettings() {
          const selectedColor = colorPicker ? colorPicker.value : '#000000';
          const currentBrushSize = brushSize ? brushSize.value : 5;

          if (state.tool === 'eraser') {
              ctx.strokeStyle = '#FFFFFF';
              ctx.fillStyle = '#FFFFFF'; // Ensure fillStyle is set for eraser in pixel mode
          } else {
              ctx.strokeStyle = selectedColor;
              ctx.fillStyle = selectedColor; // Ensure fillStyle is set for brush/fill in pixel mode
          }
          ctx.lineWidth = currentBrushSize;
          ctx.lineCap = 'round';
          ctx.lineJoin = 'round';
      }


      function drawGrid() { // Revised grid drawing function
          if (!gtx || !gridCanvas) return; // Guard clause

          const width = gridCanvas.width; // Use canvas intrinsic width/height
          const height = gridCanvas.height;

          gtx.clearRect(0, 0, width, height); // Clear the entire grid canvas
          gtx.save(); // Save context state

          // Translate the grid context origin to align with the drawing canvas's content area top-left
          gtx.translate(canvasBorderSize, canvasBorderSize);

          gtx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
          gtx.lineWidth = 0.5; // Keep thin lines

          
          const effectiveWidth = width - canvasBorderSize * 2;
          const effectiveHeight = height - canvasBorderSize * 2;

          // Draw vertical lines relative to the translated origin
          // Start from the first grid line position (pixelSize) up to the effective width
          for (let x = pixelSize; x < effectiveWidth; x += pixelSize) {
            gtx.beginPath();
            // Draw line from (x - 0.5, 0) to (x - 0.5, effectiveHeight) in the translated coordinate space
            gtx.moveTo(x - 0.5, 0);
            gtx.lineTo(x - 0.5, effectiveHeight);
            gtx.stroke();
          }

          
          for (let y = pixelSize; y < effectiveHeight; y += pixelSize) {
            gtx.beginPath();
           
            gtx.moveTo(0, y - 0.5);
            gtx.lineTo(effectiveWidth, y - 0.5);
            gtx.stroke();
          }

          gtx.restore(); 
      }

      function updateUndoRedoButtons() {
          const undoDisabled = state.undoStack.length <= 1;
          const redoDisabled = state.redoStack.length === 0;

          if (undoBtn) {
              undoBtn.disabled = undoDisabled;
          }
          if (redoBtn) {
              redoBtn.disabled = redoDisabled;
          }
          
      }

      function togglePixelMode() {
        pixelMode = !pixelMode;
        console.log('Toggling Pixel Mode. New state:', pixelMode); // Log mode toggle
        ctx.imageSmoothingEnabled = !pixelMode;

        // Hide/show brush size controls based on pixel mode AND fill tool state
        const brushControlsDiv = brushSize ? brushSize.closest('.brush-controls') : null; // Find the container
        // Add console log to verify selection
        console.log('Selected brush controls container:', brushControlsDiv);

        if (brushControlsDiv) {
            const shouldHide = pixelMode || state.tool === 'fill'; // Hide if pixel mode OR fill tool is active
            const newDisplay = shouldHide ? 'none' : 'block';
            console.log(`Pixel Toggle: Setting brushControlsDiv display to: ${newDisplay} (pixelMode: ${pixelMode}, tool: ${state.tool})`);
            brushControlsDiv.style.display = newDisplay;
        } else if (brushSize) {
             console.warn('brushControlsDiv not found, disabling brushSize slider directly.');
            brushSize.disabled = pixelMode;
        } else {
             console.warn('Neither brushControlsDiv nor brushSize element found.');
        }

        if (gridCanvas) {
             if (pixelMode) {
                gridCanvas.style.display = 'block';
                drawGrid();
             } else {
                gridCanvas.style.display = 'none';
             }
        }
        state.lastSnappedX = -1;
        state.lastSnappedY = -1;
        updateCursorStyle();
      }

      function updateCursorStyle() {
          if (!canvas) return;
          let cursorStyle = 'crosshair'; // Default

          if (pixelMode) {
              cursorStyle = 'cell';
          } else if (state.tool === 'fill') {
               cursorStyle = 'copy';
          } else if (state.tool === 'eraser') {
               cursorStyle = 'crosshair';
          } else {
              cursorStyle = 'crosshair';
          }
          canvas.style.cursor = cursorStyle;
          
      }


      function saveState() {
        if (state.undoStack.length >= state.maxStates) {
          state.undoStack.shift();
        }
        state.undoStack.push(canvas.toDataURL());
        state.redoStack = []; 
        updateUndoRedoButtons(); 
      }

      function restoreState(url) {
        const img = new Image();
        img.onload = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0);
        };
        img.src = url;
      }

      function undo() {
        if (state.undoStack.length > 1) {
          state.redoStack.push(state.undoStack.pop());
          restoreState(state.undoStack[state.undoStack.length - 1]);
          updateUndoRedoButtons(); 
        }
      }

      function redo() {
        if (state.redoStack.length > 0) {
          const nextState = state.redoStack.pop();
          state.undoStack.push(nextState);
          restoreState(nextState);
          updateUndoRedoButtons(); 
        }
      }

      // --- Flood Fill (Keep, but maybe test separately later??) ---
       function floodFill(x, y) { 
            updateContextSettings(); 
            const fillColor = ctx.fillStyle; 
            if (!/^#[0-9A-F]{6}$/i.test(fillColor)) return;

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const pixels = imageData.data;
            const startPos = (Math.floor(y) * canvas.width + Math.floor(x)) * 4;

            if (startPos < 0 || startPos >= pixels.length - 3) return;

            const targetR = pixels[startPos];
            const targetG = pixels[startPos + 1];
            const targetB = pixels[startPos + 2];
            const targetA = pixels[startPos + 3];

            if (targetA < 250) return;

            const fillR = parseInt(fillColor.substr(1, 2), 16);
            const fillG = parseInt(fillColor.substr(3, 2), 16);
            const fillB = parseInt(fillColor.substr(5, 2), 16);

            if (targetR === fillR && targetG === fillG && targetB === fillB) return;

            const tolerance = 10;

            function colorMatches(pos) {
              if (pos < 0 || pos >= pixels.length - 3) return false;
              if (pixels[pos + 3] < 250) return false;
              return (
                Math.abs(pixels[pos] - targetR) <= tolerance &&
                Math.abs(pixels[pos + 1] - targetG) <= tolerance &&
                Math.abs(pixels[pos + 2] - targetB) <= tolerance
              );
            }

            function setPixel(pos) {
              pixels[pos] = fillR;
              pixels[pos + 1] = fillG;
              pixels[pos + 2] = fillB;
              pixels[pos + 3] = 255;
            }

            const queue = [[Math.floor(x), Math.floor(y)]];
            const processed = new Set([`${Math.floor(x)},${Math.floor(y)}`]);
            let iterations = 0;
            const maxIterations = canvas.width * canvas.height * 2;

            while (queue.length > 0 && iterations < maxIterations) {
              iterations++;
              const [cx, cy] = queue.shift();
              const currentPos = (cy * canvas.width + cx) * 4;

              if (!colorMatches(currentPos)) continue;

              setPixel(currentPos);

              const neighbors = [[cx + 1, cy], [cx - 1, cy], [cx, cy + 1], [cx, cy - 1]];
              for (const [nx, ny] of neighbors) {
                  const nKey = `${nx},${ny}`;
                  if (nx >= 0 && nx < canvas.width && ny >= 0 && ny < canvas.height && !processed.has(nKey)) {
                       processed.add(nKey);
                       const neighborPos = (ny * canvas.width + nx) * 4;
                      if (colorMatches(neighborPos)) {
                           queue.push([nx, ny]);
                      }
                  }
              }
            }
             if (iterations >= maxIterations) console.error("Flood fill exceeded max iterations.");
            ctx.putImageData(imageData, 0, 0);
      }
      // --- End Flood Fill ---


      function getCoordinates(e) {
        const rect = canvas.getBoundingClientRect();
        if (!rect.width || !rect.height) return { x: NaN, y: NaN };
        return {
          x: (e.clientX - rect.left) * (canvas.width / rect.width),
          y: (e.clientY - rect.top)  * (canvas.height / rect.height)
        };
      }

      function getTouchCoordinates(e) {
        const rect = canvas.getBoundingClientRect();
        if (!rect.width || !rect.height) return { x: NaN, y: NaN };
        const t = e.touches[0] || e.changedTouches[0];
        if (!t) return { x: NaN, y: NaN };
        return {
          x: (t.clientX - rect.left) * (canvas.width / rect.width),
          y: (t.clientY - rect.top)  * (canvas.height / rect.height)
        };
      }


      // --- Drawing Event Handlers  ---

      function startDrawing(e) {
        const coords = getCoordinates(e);
        if (isNaN(coords.x) || isNaN(coords.y)) return;

        state.isDrawing = true;
        [state.lastX, state.lastY] = [coords.x, coords.y];
        state.lastSnappedX = -1; // Reset snap state
        state.lastSnappedY = -1;

        updateContextSettings();

        if (state.tool === 'fill') {
          floodFill(coords.x, coords.y);
          saveState();
          state.isDrawing = false;
        } else if (pixelMode) { // Re-add pixel mode logic
          const x = Math.floor(coords.x / pixelSize) * pixelSize;
          const y = Math.floor(coords.y / pixelSize) * pixelSize;
          ctx.fillRect(x, y, pixelSize, pixelSize); // Draw first pixel block
          state.lastSnappedX = x;
          state.lastSnappedY = y;
          // Don't save state until stopDrawing this was really annoying..
        } else {
          // Standard brush/eraser start
          ctx.beginPath();
          ctx.moveTo(coords.x, coords.y);
        }
      }

      function draw(e) {
        if (!state.isDrawing) return;
        const coords = getCoordinates(e);
         if (isNaN(coords.x) || isNaN(coords.y)) return;

        if (pixelMode) { // Re-add pixel mode logic
            if (state.tool !== 'fill') {
                const x = Math.floor(coords.x / pixelSize) * pixelSize;
                const y = Math.floor(coords.y / pixelSize) * pixelSize;
                // Only draw if snapped position changes
                if (x !== state.lastSnappedX || y !== state.lastSnappedY) {
                    updateContextSettings(); // Ensure fillStyle is current
                    ctx.fillRect(x, y, pixelSize, pixelSize);
                    state.lastSnappedX = x;
                    state.lastSnappedY = y;
                }
            }
         } else { // Standard brush/eraser drawing
             if (state.tool !== 'fill') {
                 updateContextSettings(); // Ensure settings are current
                 ctx.lineTo(coords.x, coords.y);
                 ctx.stroke();
                 [state.lastX, state.lastY] = [coords.x, coords.y];
             }
         }
      }

      function stopDrawing() {
        if (state.isDrawing) {
          if (state.tool !== 'fill') {
            saveState();
          }
          state.isDrawing = false;
        }
      }


      // --- Touch Handlers (Re-integrate Pixel Mode) ---

       function startDrawingTouch(e) {
        e.preventDefault();
        const coords = getTouchCoordinates(e);
        if (isNaN(coords.x) || isNaN(coords.y)) return;

        state.isDrawing = true;
        [state.lastX, state.lastY] = [coords.x, coords.y];
        state.lastSnappedX = -1;
        state.lastSnappedY = -1;

        updateContextSettings();

        if (state.tool === 'fill') {
          floodFill(coords.x, coords.y);
          saveState();
          state.isDrawing = false;
        } else if (pixelMode) { // Re-add pixel mode logic
          const x = Math.floor(coords.x / pixelSize) * pixelSize;
          const y = Math.floor(coords.y / pixelSize) * pixelSize;
          ctx.fillRect(x, y, pixelSize, pixelSize);
          state.lastSnappedX = x;
          state.lastSnappedY = y;
        } else {
          ctx.beginPath();
          ctx.moveTo(coords.x, coords.y);
        }
      }

      function drawTouch(e) {
        e.preventDefault();
        if (!state.isDrawing) return;
        const coords = getTouchCoordinates(e);
         if (isNaN(coords.x) || isNaN(coords.y)) return;

        if (pixelMode) { // Re-add pixel mode logic
            if (state.tool !== 'fill') {
                const x = Math.floor(coords.x / pixelSize) * pixelSize;
                const y = Math.floor(coords.y / pixelSize) * pixelSize;
                if (x !== state.lastSnappedX || y !== state.lastSnappedY) {
                    updateContextSettings();
                    ctx.fillRect(x, y, pixelSize, pixelSize);
                    state.lastSnappedX = x;
                    state.lastSnappedY = y;
                }
            }
        } else { // Standard brush/eraser drawing
            if (state.tool !== 'fill') {
                updateContextSettings();
                ctx.lineTo(coords.x, coords.y);
                ctx.stroke();
                [state.lastX, state.lastY] = [coords.x, coords.y];
            }
        }
      }

       function stopDrawingTouch(e) { // Unchanged from simplified version
        e.preventDefault();
         if (state.isDrawing) {
            if (state.tool !== 'fill') {
                saveState();
            }
            state.isDrawing = false;
        }
      }

      // --- Initialization & Control Listeners ---

      ctx.fillStyle = '#FFFFFF';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      updateContextSettings();
      updateCursorStyle(); // Set initial cursor

      // Event listeners for drawing actions
      canvas.addEventListener('mousedown', startDrawing);
      canvas.addEventListener('mousemove', draw);
      canvas.addEventListener('mouseup', stopDrawing);
      canvas.addEventListener('mouseout', stopDrawing);

      canvas.addEventListener('touchstart', startDrawingTouch, { passive: false });
      canvas.addEventListener('touchmove', drawTouch, { passive: false });
      canvas.addEventListener('touchend', stopDrawingTouch, { passive: false });
      canvas.addEventListener('touchcancel', stopDrawingTouch, { passive: false });


      // Tool button listeners
      const toolBtns = {
        brush: document.getElementById('brushBtn'),
        eraser: document.getElementById('eraserBtn'),
        fill: document.getElementById('fillBtn')
      };
      Object.entries(toolBtns).forEach(([tool, btn]) => {
        if (!btn) return;
        btn.addEventListener('click', () => {
          // console.log('Tool selected:', tool); // Uncomment for tool logging
          Object.values(toolBtns).forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          state.tool = tool;
          updateContextSettings();
          updateCursorStyle();
           // Update brush controls visibility based on tool AND pixel mode
           if (brushControlsDiv) {
                const shouldHide = pixelMode || state.tool === 'fill'; // Hide if pixel mode OR fill tool is active
                const newDisplay = shouldHide ? 'none' : 'block';
                console.log(`Tool Click (${tool}): Setting brushControlsDiv display to: ${newDisplay} (pixelMode: ${pixelMode}, tool: ${state.tool})`);
                brushControlsDiv.style.display = newDisplay;
            } else {
                 console.warn(`Tool click (${tool}): brushControlsDiv not found.`);
            }
        });
      });

      // Other control listeners
      const pixelBtn = document.getElementById('pixelBtn');
      if (pixelBtn) pixelBtn.addEventListener('click', togglePixelMode);

      const undoBtn = document.getElementById('undoBtn');
      const redoBtn = document.getElementById('redoBtn');
      const clearBtn = document.getElementById('clearBtn');

      if (undoBtn) undoBtn.addEventListener('click', undo);
      if (redoBtn) redoBtn.addEventListener('click', redo);
      if (colorPicker) colorPicker.addEventListener('input', updateContextSettings);
      if (brushSize) {
        brushSize.addEventListener('input', e => {
          if (!pixelMode) { // Only update if slider is visible/enabled
              updateContextSettings();
          }
          const brushDisplay = document.getElementById('brushSizeDisplay');
          if (brushDisplay) brushDisplay.textContent = `${e.target.value}px`;
        });
      }
      if (clearBtn) {
        clearBtn.addEventListener('click', () => {
          ctx.fillStyle = 'white';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          updateContextSettings();
          saveState();
        });
      }

      // --- Initial Save & Button State ---
      saveState();
      updateUndoRedoButtons();
      // Ensure initial brush control visibility is correct
      if (brushControlsDiv) {
           const initialHide = pixelMode || state.tool === 'fill'; // Check initial state
           brushControlsDiv.style.display = initialHide ? 'none' : 'block';
           console.log(`Initial: Setting brushControlsDiv display to: ${initialHide ? 'none' : 'block'} (pixelMode: ${pixelMode}, tool: ${state.tool})`);
      } else {
           console.warn('Initial: brushControlsDiv not found.');
      }


      return { canvas, ctx };
    } // End of initDrawingCanvas

    function initializeMessageBox() {
      const messageText = document.getElementById('messageText');
      const sendMessageBtn = document.getElementById('sendMessageBtn');

      async function sendMessage() {
        const message = messageText.value.trim();
        if (!message) {
          alert('Message cannot be empty.');
          return;
        }
        sendMessageBtn.disabled = true;
        sendMessageBtn.textContent = 'Sending...';
        try {
          const webhookUrl = 'https://discord.com/api/webhooks/1325711944077807627/YkT0v182B_7DBRoPzhld0_JeGEHwrvqoF69SJu_wh8yYTrPvzo-TBPbpS8NC9CLobWZe';
          const timeStamp = new Date().toLocaleTimeString('en-US', {
            hour: '2-digit', minute: '2-digit', hour12: true, timeZone: 'America/New_York'
          });
          const payload = {
            username: `Question Hook - ${timeStamp}`,
            content: `**New Message!**\n\n${message}`,
			avatar_url: 'https://cdn.pixabay.com/photo/2019/02/24/18/30/pirate-4018168_1280.png'
          };
          const response = await fetch(webhookUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload),
          });
          if (!response.ok) throw new Error(response.statusText);
          sendMessageBtn.textContent = 'Message Sent!';
          messageText.value = '';
        } catch (error) {
          sendMessageBtn.textContent = 'Error Sending';
        } finally {
          setTimeout(() => {
            sendMessageBtn.disabled = false;
            sendMessageBtn.textContent = 'Send Message';
          }, 20000);
        }
      }

      sendMessageBtn.addEventListener('click', sendMessage);
      messageText.addEventListener('keydown', e => {
        if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
          e.preventDefault();
          sendMessage();
        }
      });
    }

    document.addEventListener('DOMContentLoaded', () => {
      const tabList = document.getElementById('tabList');
      const tabContent = document.getElementById('tabContent');

      tabs.forEach(tab => {
        const button = document.createElement('button');
        button.className = 'blog-post';
        button.textContent = tab.title;
        button.dataset.tabId = tab.id;
        tabList.appendChild(button);
      });

      function activateTab(tabId) {
        document.querySelectorAll('.blog-post').forEach(btn => {
          btn.classList.remove('active');
        });
        document.querySelector(`[data-tab-id="${tabId}"]`).classList.add('active');

        const tab = tabs.find(t => t.id === tabId);
        tabContent.innerHTML = tab.content;

        if (tabId === 'tab-4') {
          setTimeout(() => {
            const canvasSetup = initDrawingCanvas();
            if (canvasSetup) {
              currentCanvas = canvasSetup.canvas;
              currentContext = canvasSetup.ctx;
            }
            initializeMessageBox();
          }, 100);
        }
      }

      tabList.addEventListener('click', e => {
        const button = e.target.closest('.blog-post');
        if (!button) return;
        activateTab(button.dataset.tabId);
      });

      tabList.addEventListener('keydown', e => {
        const button = e.target.closest('.blog-post');
        if (!button) return;
        const buttons = [...document.querySelectorAll('.blog-post')];
        const currentIndex = buttons.indexOf(button);
        let newIndex;
        switch(e.key) {
          case 'ArrowRight':
          case 'ArrowDown':
            newIndex = (currentIndex + 1) % buttons.length;
            break;
          case 'ArrowLeft':
          case 'ArrowUp':
            newIndex = (currentIndex - 1 + buttons.length) % buttons.length;
            break;
          default:
            return;
        }
        e.preventDefault();
        buttons[newIndex].focus();
        activateTab(buttons[newIndex].dataset.tabId);
      });

      activateTab('tab-4');
    });

    const createStarryBackground = () => {
      const background = document.createElement('div');
      Object.assign(background.style, {
        position: 'fixed',
        top: '0',
        left: '0',
        width: '100%',
        height: '100%',
        pointerEvents: 'none',
        zIndex: '-1'
      });
      const fragment = document.createDocumentFragment();
      const numStars = 200;
      for (let i = 0; i < numStars; i++) {
        const star = document.createElement('div');
        const size = Math.random() * 3 + 1;
        Object.assign(star.style, {
          position: 'absolute',
          backgroundColor: '#fff',
          borderRadius: '50%',
          opacity: Math.random(),
          width: `${size}px`,
          height: `${size}px`,
          top: `${Math.random() * 100}%`,
          left: `${Math.random() * 100}%`,
          animation: `twinkle ${Math.random() * 3 + 2}s infinite alternate`
        });
        fragment.appendChild(star);
      }
      background.appendChild(fragment);
      document.body.appendChild(background);
    };
    createStarryBackground();

    function initKeyboardShortcuts() {
      document.addEventListener('keydown', e => {
        if (e.ctrlKey || e.metaKey) {
          switch (e.key.toLowerCase()) {
            case 'z':
              e.preventDefault();
              if (e.shiftKey) {
                document.getElementById('redoBtn').click();
              } else {
                document.getElementById('undoBtn').click();
              }
              break;
            case 'y':
              e.preventDefault();
              document.getElementById('redoBtn').click();
              break;
          }
        }
      });
    }
  </script>
</body>
</html>
